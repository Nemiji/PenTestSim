import numpy as np
import gym
from gym import spaces
from gym.spaces import Box, Discrete
from collections import defaultdict
import hashlib
import networkx as nx
import matplotlib.pyplot as plt
from Node import PenTestSim_Node


class PenTestSim(gym.Env):

    def __init__(self):

        self.small_1 = [[[0,1,0,0,0,0],[1,0,1,1,0,0],[0,1,0,1,1,0],[0,1,1,0,0,1],[0,0,1,0,0,0],[0,0,0,1,0,0]],4,[2]]
        self.small_2 = [[[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[1,1,1,0,1,1,0,0],[0,0,0,1,0,1,0,0],[0,0,0,1,1,0,1,1],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0]],6,[3,5]]
        self.enterprise_2 = [[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]],14,[3,6,10,11,13,16,21]]
        self.nb_nodes = len(self.small_1[0])
        # Three action types: Discovery (==0) or Connection (==1) or Priv_Esc (==2), Targeted Node
        # Now more actions thant that:
        # Scans: 0 - Check only connections from this node to other nodes. COST: 1 (type 0 x Current node ID)
        # 1 - Check Properties of a selected discovered node. COST: 1 (type 1 x Selected Node ID (needs to be alreday discovered))
        # 2 - Discover and chek properties of all the adjacent nodes. COST: 3 (type 2 x Current Node ID)
        # Connection: 3 - Connect to selected node with 80% chance if node of type 0, 20% else. COST: 1
        # 4 - Connect ... to type 1. COST: 1
        # 5 -  Connect ... to type 2. COST: 1
        # PrivESC: 6 - Escalate Privs in current node. COST: 1
        self.action_space = spaces.MultiDiscrete([7,self.nb_nodes])
        self.observation_space = spaces.Dict({
            # Contains scan statuses of adjacent nodes
            'available_nodes' : spaces.Box(0,2,(self.nb_nodes,),dtype=np.int8),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2),
            # Contains the OS types of the adjacent nodes
            'OS_type' : spaces.Box(0,3,(self.nb_nodes,),dtype=np.int8)
        })
        self.goal_id = self.small_1[1]
        self.important_nodes = self.small_1[2]
        self.node_conns = [[0,1,0,0,0,0],[1,0,1,1,0,0],[0,1,0,1,1,0],[0,1,1,0,0,1],[0,0,1,0,0,0],[0,0,0,1,0,0]]
        self.nx_layout = None                
        self.nodes = self._init_nodes()
        self.current_node = self.nodes[0]
        self.cost = 0



    def reset(self):
        self.nodes = self._init_nodes()
        self.current_node = self.nodes[0]
        available_nodes = np.zeros(self.nb_nodes,dtype=int)
        available_nodes[self.current_node.id] = self.current_node.scan_status
        os_type = np.zeros(self.nb_nodes,dtype=int)
        os_type[self.current_node.id] = self.current_node.os_type
        obs = {
            'available_nodes' : available_nodes.tolist(),
            'current_node' : self.current_node.id,
            'escalation_status' : self.current_node.escalation_status,
            'importance_lvl' : self.current_node.importance_lvl,
            'OS_type' : os_type.tolist()
        }
        return obs


    def step(self, action):
        r = 0
        done = False
        a_val = False
        info = []

        a_val, info = self._is_action_valid(action)
        if a_val:
            tmp_info = self._do_action(action)
            done = self._is_end()
            if done:
                r = 100
            if tmp_info != None:
                info = tmp_info
        available_nodes = np.zeros(self.nb_nodes,dtype=int)
        os_type = np.zeros(self.nb_nodes,dtype=int)
        
        for i in range(self.nb_nodes):
            # Only display scan status (and potentially OS Type) of nodes which are adjacent
            if (self.nodes[i].scan_status >= 1) and (self.node_conns[self.current_node.id][i] == 1):
                available_nodes[i] = self.nodes[i].scan_status
                if self.nodes[i].scan_status == 2:
                    os_type[i] = self.nodes[i].os_type
            else:
                available_nodes[i] = 0
                os_type[i] = 3
        # The OS of the current Node is of course already known => scan status of current node switches to 2 after visiting it
        os_type[self.current_node.id] = self.current_node.os_type
        available_nodes[self.current_node.id] = self.current_node.scan_status


        obs = {
                'available_nodes' : available_nodes.tolist(),
                'current_node' : self.current_node.id,
                'node_scan_status' : self.current_node.scan_status,
                'escalation_status' : self.current_node.escalation_status,
                'importance_lvl' : self.current_node.importance_lvl,
                'OS_type' : os_type.tolist(),
            }
        r = r - self.cost
        return obs, r, done, info
            

    
    def valid_action_sample(self):
        valid_actions = []
        if (self.current_node.importance_lvl == 1) and (self.current_node.escalation_status != 1):
            return (6, self.current_node.id)
        for i in range(self.nb_nodes):
            if self.node_conns[self.current_node.id][i] == 1:
                valid_actions.append(i)
            action = np.random.choice(valid_actions)
            if self.nodes[action].os_type == 0:
                return(0, action)
            elif self.nodes[action].os_type == 1:
                return(1, action)
            elif self.nodes[action].os_type == 2:
                return(2, action)
        return (2, self.current_node.id)
    
    
    # TO DO: At the moment all nodes are of type 0. Need to construct a mechanism to implement variety in it
    def _init_nodes(self):
        node_list = []
        for i in range(self.nb_nodes):
            importance = 0
            if i in self.important_nodes:
                importance = 1
            node_list.append(PenTestSim_Node(
                i, self.node_conns[i], importance, 0, 0, 0
            ))
        return node_list



    def hashed_obs(self, obs):
        stringed_obs = str(obs)
        return hashlib.md5(stringed_obs.encode()).hexdigest()
    
    # TO DO: Implement the node props in network chars ?
    def change_network(self, env):
        if env == 'small_1':
            self.nb_nodes = len(self.small_1[0])
            self.node_conns = self.small_1[0]
            self.goal_id = self.small_1[1]
            self.important_nodes = self.small_1[2]
            self.observation_space = spaces.Dict({
            'available_nodes' : spaces.Box(0,2,(self.nb_nodes,),dtype=np.int8),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'node_scan_status' : spaces.Discrete(3),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2),
            'OS_type' : spaces.Box(0,3,(self.nb_nodes,),dtype=np.int8)
            })
            self.action_space = spaces.MultiDiscrete([7,self.nb_nodes])
            print("Changed to ENV: SMALL_1")
        elif env == 'small_2':
            self.nb_nodes = len(self.small_2[0])
            self.node_conns = self.small_2[0]
            self.goal_id = self.small_2[1]
            self.important_nodes = self.small_2[2]
            self.observation_space = spaces.Dict({
            'available_nodes' : spaces.Box(0,2,(self.nb_nodes,),dtype=np.int8),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'node_scan_status' : spaces.Discrete(3),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2),
            'OS_type' : spaces.Box(0,3,(self.nb_nodes,),dtype=np.int8)
            })
            self.action_space = spaces.MultiDiscrete([7,self.nb_nodes])
            print("Changed to ENV: SMALL_2")
        elif env == 'enterprise_2':
            self.nb_nodes = len(self.enterprise_2[0])
            self.node_conns = self.enterprise_2[0]
            self.goal_id = self.enterprise_2[1]
            self.important_nodes = self.enterprise_2[2]
            self.observation_space = spaces.Dict({
            'available_nodes' : spaces.Box(0,2,(self.nb_nodes,),dtype=np.int8),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'node_scan_status' : spaces.Discrete(3),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2),
            'OS_type' : spaces.Box(0,3,(self.nb_nodes,),dtype=np.int8)
            })
            self.action_space = spaces.MultiDiscrete([7,self.nb_nodes])
            print("Changed to ENV: ENTERPRISE_2")
            
    
    def _is_a0_valid(self, action):
        if self.current_node.id != action[1]:
            return False, "Cannot scan node without being in it !"
        return True, "Scan successful !"
    
    def _is_a1_valid(self, action):
        if (self.node_conns[self.current_node.id][action[1]] == 1) and (self.nodes[action[1]].scan_status == 1):
            return True, "OS Scan successful"
        return False, "Scan Target invalid !"
    
    def _is_a2_valid(self, action):
        if self.current_node.id != action[1]:
            return False, "Cannot scan node without being in it !"
        return True, "Scan successful !"
    

    def _is_a3_valid(self,action):
        if (self.nodes[action[1]].scan_status == 0) or (self.node_conns[self.current_node.id][action[1]] != 1):
            return False, "Connection is impossible !"
        if (self.current_node.escalation_status == 0) and (self.current_node.importance_lvl == 1):
            return False, "Cannot connect to new node with current privileges !"
        return True, "Connection successful !"
    

    def _is_a4_valid(self,action):
        if (self.nodes[action[1]].scan_status == 0) or (self.node_conns[self.current_node.id][action[1]] != 1):
            return False, "Connection is impossible !"
        if (self.current_node.escalation_status == 0) and (self.current_node.importance_lvl == 1):
            return False, "Cannot connect to new node with current privileges !"
        return True, "Connection successful !"
    
    def _is_a5_valid(self,action):
        if (self.nodes[action[1]].scan_status == 0) or (self.node_conns[self.current_node.id][action[1]] != 1):
            return False, "Connection is impossible !"
        if (self.current_node.escalation_status == 0) and (self.current_node.importance_lvl == 1):
            return False, "Cannot connect to new node with current privileges !"
        return True, "Connection successful !"
    
    def _is_a6_valid(self, action):
        if action[1] != self.current_node.id:
            return False, "Cannot escalate node without being in it !"
        return True, "PrivEsc successful !"
        
    def _is_action_valid(self,action):
        if action[0] == 0:
            return self._is_a0_valid(action)
        elif action[0] == 1:
            return self._is_a1_valid(action)
        elif action[0] == 2:
            return self._is_a2_valid(action) 
        elif action[0] == 3:
            return self._is_a3_valid(action)
        elif action[0] == 4:
            return self._is_a4_valid(action)
        elif action[0] == 5:
            return self._is_a5_valid(action)
        elif action[0] == 6:
            return self._is_a6_valid(action)
        
    
    def _do_a0(self, action):
        for i in range(self.nb_nodes):
            if self.node_conns[self.current_node.id][i] == 1:
                self.nodes[i].scan_type = 1

    def _do_a1(self, action):
        if self.node_conns[self.current_node.id][action[1]] == 1:
            self.nodes[action[1]].scan_status = 2


    def _do_a2(self,action):
        self.nodes[self.current_node.id].scan_status = 2
        for i in range(self.nb_nodes):
            if self.node_conns[self.current_node.id][i] == 1:
                self.nodes[i].scan_type = 2

    def _do_a3(self, action):
        if self.nodes[action[1]].os_type == 0:
            if np.random.random < 0.8:
                self.current_node = self.nodes[action[1]]
                self.nodes[action[1]].scan_status = 2
            else:
                return "Connection failed !"
        else:
            if np.random.random < 0.2:
                self.current_node = self.nodes[action[1]]
            else:
                return "Connection failed !"

    def _do_a4(self, action):
        if self.nodes[action[1]].os_type == 1:
            if np.random.random < 0.8:
                self.current_node = self.nodes[action[1]]
                self.nodes[action[1]].scan_status = 2
            else:
                return "Connection failed !"
        else:
            if np.random.random < 0.2:
                self.current_node = self.nodes[action[1]]
            else:
                return "Connection failed !"

    def _do_a5(self, action):
        if self.nodes[action[1]].os_type == 2:
            if np.random.random < 0.8:
                self.current_node = self.nodes[action[1]]
                self.nodes[action[1]].scan_status = 2
            else:
                return "Connection failed !"
        else:
            if np.random.random < 0.2:
                self.current_node = self.nodes[action[1]]
            else:
                return "Connection failed !"

    def _do_a6(self, action):
        self.nodes[self.current_node.id].escalation_status = 1


    def _do_action(self, action):
        info = None
        cost = 1
        if action[0] == 0:
            self._do_a0(action)
        elif action[0] == 1:
            self._do_a1(action)
        elif action[0] == 2:
            self._do_a2(action)
            cost = 3
        elif action[0] == 3:
           info = self._do_a3(action)
        elif action[0] == 4:
            info = self._do_a4(action)
        elif action[0] == 5:
            info = self._do_a5
        elif action[0] == 6:
            info = self._do_a6
        self.cost = cost
        self.current_node = self.nodes[self.current_node.id] # Allows a reupdate of the characteristics of the current node as the "nodes" list is the one who centralizes modifications
        return info


    def _is_end(self):
        return self.current_node.id == self.goal_id
    

    # TO DO: Color code for OS types ?
    def render(self):
        color_map = []
        G = nx.Graph()
        for i in range(self.nb_nodes):
            if i == self.current_node.id:
                color_map.append('green')
            elif i in self.important_nodes:
                color_map.append('red')
            elif i == self.goal_id:
                color_map.append('gold')
            else:
                color_map.append('blue')
            G.add_node(i)
            for j in range(self.nb_nodes):
                if self.node_conns[i][j]:
                    G.add_edge(i,j)
        if self.nx_layout == None:
            self.nx_layout = nx.spring_layout(G)
        nx.draw(G, pos=self.nx_layout, node_color=color_map, with_labels=True)

        