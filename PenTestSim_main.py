import numpy as np
import gym
from gym import spaces
from gym.spaces import Box, Discrete
from collections import defaultdict
import hashlib
import networkx as nx
import matplotlib.pyplot as plt
from Node import PenTestSim_Node


class PenTestSim(gym.Env):

    def __init__(self):

        self.small_1 = [[[0,1,0,0,0,0],[1,0,1,1,0,0],[0,1,0,1,1,0],[0,1,1,0,0,1],[0,0,1,0,0,0],[0,0,0,1,0,0]],4,[2]]
        self.small_2 = [[[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[1,1,1,0,1,1,0,0],[0,0,0,1,0,1,0,0],[0,0,0,1,1,0,1,1],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0]],6,[3,5]]
        self.enterprise_2 = [[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]],14,[3,6,10,11,13,16,21]]
        self.nb_nodes = len(self.small_1[0])
        # Three action types: Discovery (==0) or Connection (==1) or Priv_Esc (==2), Targeted Node
        self.action_space = spaces.MultiDiscrete([3,self.nb_nodes])
        self.observation_space = spaces.Dict({
            'available_nodes' : spaces.MultiBinary(self.nb_nodes),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'node_scan_status' : spaces.Discrete(2),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2)
        })
        self.goal_id = self.small_1[1]
        self.important_nodes = self.small_1[2]
        self.node_conns = [[0,1,0,0,0,0],[1,0,1,1,0,0],[0,1,0,1,1,0],[0,1,1,0,0,1],[0,0,1,0,0,0],[0,0,0,1,0,0]]
        self.nx_layout = None                
        self.nodes = self._init_nodes()
        self.current_node = self.nodes[0]



    def reset(self):
        self.nodes = self._init_nodes()
        self.current_node = self.nodes[0]
        obs = {
            'available_nodes' : np.zeros(self.nb_nodes,dtype=int).tolist(),
            'current_node' : self.current_node.id,
            'node_scan_status' : self.current_node.scan_status,
            'escalation_status' : self.current_node.escalation_status,
            'importance_lvl' : self.current_node.importance_lvl
        }
        return obs


    def step(self, action):
        r = 0
        done = False
        a_val = False
        info = []

        a_val, info = self._is_action_valid(action)
        if a_val:
            self._do_action(action)
            done = self._is_end()
            if done:
                r = 1

        obs = {
                'available_nodes' : np.zeros(self.nb_nodes,dtype=int).tolist(),
                'current_node' : self.current_node.id,
                'node_scan_status' : self.current_node.scan_status,
                'escalation_status' : self.current_node.escalation_status,
                'importance_lvl' : self.current_node.importance_lvl
            }
        if self.current_node.scan_status == 1:
            obs['available_nodes'] = self.current_node.connections
        return obs, r, done, info
            

    def valid_action_sample(self):
        valid_actions = []
        if (self.current_node.importance_lvl == 1) and (self.current_node.escalation_status != 1):
            return (2, self.current_node.id)
        if self.current_node.scan_status == 1:
            for i in range(self.nb_nodes):
                if self.current_node.connections[i] == 1:
                    valid_actions.append(i)
            return (1,np.random.choice(valid_actions))
        return (0,self.current_node.id)
    
    
    def _init_nodes(self):
        node_list = []
        for i in range(self.nb_nodes):
            importance = 0
            if i in self.important_nodes:
                importance = 1
            node_list.append(PenTestSim_Node(
                i, self.node_conns[i], importance, 0, 0
            ))
        return node_list



    def hashed_obs(self, obs):
        stringed_obs = str(obs)
        return hashlib.md5(stringed_obs.encode()).hexdigest()
    
    def change_network(self, env):
        if env == 'small_1':
            self.nb_nodes = len(self.small_1[0])
            self.node_conns = self.small_1[0]
            self.goal_id = self.small_1[1]
            self.important_nodes = self.small_1[2]
            self.observation_space = spaces.Dict({
            'available_nodes' : spaces.MultiBinary(self.nb_nodes),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'node_scan_status' : spaces.Discrete(2),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2)
            })
            self.action_space = spaces.MultiDiscrete([3,self.nb_nodes])
            print("Changed to ENV: SMALL_1")
        elif env == 'small_2':
            self.nb_nodes = len(self.small_2[0])
            self.node_conns = self.small_2[0]
            self.goal_id = self.small_2[1]
            self.important_nodes = self.small_2[2]
            self.observation_space = spaces.Dict({
            'available_nodes' : spaces.MultiBinary(self.nb_nodes),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'node_scan_status' : spaces.Discrete(2),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2)
            })
            self.action_space = spaces.MultiDiscrete([3,self.nb_nodes])
            print("Changed to ENV: SMALL_2")
        elif env == 'enterprise_2':
            self.nb_nodes = len(self.enterprise_2[0])
            self.node_conns = self.enterprise_2[0]
            self.goal_id = self.enterprise_2[1]
            self.important_nodes = self.enterprise_2[2]
            self.observation_space = spaces.Dict({
            'available_nodes' : spaces.MultiBinary(self.nb_nodes),
            'current_node' : spaces.Discrete(self.nb_nodes),
            'node_scan_status' : spaces.Discrete(2),
            'escalation_status' : spaces.Discrete(2),
            'importance_lvl' : spaces.Discrete(2)
            })
            self.action_space = spaces.MultiDiscrete([3,self.nb_nodes])
            print("Changed to ENV: ENTERPRISE_2")
            
    def _is_a0_valid(self, action):
        if self.current_node.id != action[1]:
            return False, "Cannot scan node without being in it !"
        return True, "Scan successful !"
    
    def _is_a1_valid(self,action):
        if self.current_node.scan_status == 0:
            return False, "Connect connect to nodes without knowing the base connections !"
        if (self.current_node.escalation_status == 0) and (self.current_node.importance_lvl == 1):
            return False, "Cannot connect to new node with current privileges !"
        if self.current_node.connections[action[1]] != 1:
            return False, "Connection is impossible !"
        return True, "Connection successful !"
    
    def _is_a2_valid(self, action):
        if action[1] != self.current_node.id:
            return False, "Cannot escalate node without being in it !"
        return True, "PrivEsc successful !"
        
    def _is_action_valid(self,action):
        if action[0] == 0:
            return self._is_a0_valid(action)
        elif action[0] == 1:
            return self._is_a1_valid(action)
        elif action[0] == 2:
            return self._is_a2_valid(action)
        
    
    def _do_a0(self, action):
        self.nodes[self.current_node.id].scan_status = 1

    def _do_a2(self, action):
        self.current_node = self.nodes[action[1]]

    def _do_a3(self, action):
        self.nodes[self.current_node.id].escalation_status = 1


    def _do_action(self, action):
        if action[0] == 0:
            self._do_a1(action)
        elif action[0] == 1:
            self._do_a2(action)
        elif action[0] == 2:
            self._do_a3(action)
        self.current_node = self.nodes[self.current_node.id] # Allows a reupdate of the characteristics of the current node as the "nodes" list is the one who centralizes modifications


    def _is_end(self):
        return self.current_node.id == self.goal_id
    

    def render(self):
        color_map = []
        G = nx.Graph()
        for i in range(self.nb_nodes):
            if i == self.current_node.id:
                color_map.append('green')
            elif i in self.important_nodes:
                color_map.append('red')
            elif i == self.goal_id:
                color_map.append('gold')
            else:
                color_map.append('blue')
            G.add_node(i)
            for j in range(self.nb_nodes):
                if self.node_conns[i][j]:
                    G.add_edge(i,j)
        if self.nx_layout == None:
            self.nx_layout = nx.spring_layout(G)
        nx.draw(G, pos=self.nx_layout, node_color=color_map, with_labels=True)

        